diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
index 88fed478a3..da7e15c3c5 100644
--- a/libavcodec/codec_desc.c
+++ b/libavcodec/codec_desc.c
@@ -3774,6 +3774,12 @@ static const AVCodecDescriptor codec_descriptors[] = {
         .name      = "anull",
         .long_name = NULL_IF_CONFIG_SMALL("Null audio codec"),
     },
+    /* Custom for spatial video */
+    {
+        .id        = AV_CODEC_ID_METT_DISPARITY,
+        .name      = "disparity",
+        .long_name = NULL_IF_CONFIG_SMALL("Disparity codec"),
+    },
 };
 
 static int descriptor_compare(const void *key, const void *member)
diff --git a/libavcodec/codec_id.h b/libavcodec/codec_id.h
index be0a65bcb9..977ecdbb11 100644
--- a/libavcodec/codec_id.h
+++ b/libavcodec/codec_id.h
@@ -620,6 +620,11 @@ enum AVCodecID {
      * Null encoder/decoder discard all input and never return any output.
      */
     AV_CODEC_ID_ANULL,
+
+    /**
+     * Custom spatialmp4 codec.
+     **/
+    AV_CODEC_ID_METT_DISPARITY,
 };
 
 /**
diff --git a/libavformat/mov.c b/libavformat/mov.c
index 8a094b1ea0..f4bdf93ade 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -86,6 +86,8 @@ typedef struct MOVParseTableEntry {
 static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom);
 static int mov_read_mfra(MOVContext *c, AVIOContext *f);
 static void mov_free_stream_context(AVFormatContext *s, AVStream *st);
+static int mov_read_icam(MOVContext *c, AVIOContext *pb, MOVAtom *atom);
+static int mov_read_ecam(MOVContext *c, AVIOContext *pb, MOVAtom *atom);
 
 static int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,
                                              unsigned len, const char *key)
@@ -2887,6 +2889,17 @@ static int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb,
                 }
             }
         }
+    } else if (st->codecpar->codec_tag == MKTAG('m','e','t','t')) {
+        if (size < 20) {
+            avio_skip(pb, size);
+        } else {
+            char mime[20];
+            size -= avio_get_str(pb, size, mime, 20);
+            avio_skip(pb, size);
+            if (strstr(mime, "disparity") != NULL) {
+                st->codecpar->codec_id = AV_CODEC_ID_METT_DISPARITY;
+            }
+        }
     } else {
         /* other codec type, just skip (rtp, mp4s ...) */
         avio_skip(pb, size);
@@ -9323,6 +9336,8 @@ static const MOVParseTableEntry mov_default_parse_table[] = {
 #if CONFIG_IAMFDEC
 { MKTAG('i','a','c','b'), mov_read_iacb },
 #endif
+{ MKTAG('i','c','a','m'), mov_read_icam },
+{ MKTAG('e','c','a','m'), mov_read_ecam },
 { 0, NULL }
 };
 
@@ -9344,6 +9359,9 @@ static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;
         a.size = avio_rb32(pb);
         a.type = avio_rl32(pb);
+
+        // av_log(c->fc, AV_LOG_INFO, "Found box: type='%s' size=%"PRId64" parent='%s'\n", av_fourcc2str(a.type), a.size, av_fourcc2str(atom.type));
+
         if (avio_feof(pb))
             break;
         if (((a.type == MKTAG('f','r','e','e') && c->moov_retry) ||
@@ -9448,6 +9466,115 @@ static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     return 0;
 }
 
+static int mov_read_icam(MOVContext *c, AVIOContext *pb, MOVAtom *atom)
+{
+    if (!c || !c->fc) {
+        av_log(NULL, AV_LOG_ERROR, "Invalid context for ICAM box\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    avio_rb32(pb);  // writeInt32(0)
+    // view_id: 0(left), 1(right)
+    int16_t view_id = avio_rb16(pb);  // writeInt16(view_id)
+    view_id &= 0x3FF;
+    avio_rb32(pb);  // writeInt32(31)
+    avio_rb32(pb);  // writeInt32(31)
+    avio_rb32(pb);  // writeInt32(31)
+
+    // TODO: revemo hard code for num_doubles
+    // int64_t remaining = atom->size - (4 + 2 + 4 + 4 + 4); // 减去已读取的字节数
+    // int num_doubles = remaining / (1 + sizeof(double)); // 每个值包含1字节指数和8字节尾数
+    int num_doubles = 4;     // remaining / (1 + sizeof(double)); // 每个值包含1字节指数和8字节尾数
+
+    // create a buffer to store all double values
+    char *value_str = av_malloc(num_doubles * 32); // each double has at most 32 characters
+    if (!value_str) {
+        return AVERROR(ENOMEM);
+    }
+    value_str[0] = '\0';
+
+    // read all (double) values
+    for (int i = 0; i < num_doubles; i++) {
+        int8_t exponent = avio_r8(pb);
+        double mantissa;
+        int ret = avio_read(pb, (uint8_t*)&mantissa, sizeof(double));
+        if (ret != sizeof(double)) {
+            return AVERROR_INVALIDDATA;
+        }
+        // convert the mantissa and exponent back to double
+        double dvalue = ldexp(mantissa, exponent);
+
+        char temp[32];
+        snprintf(temp, sizeof(temp), "%f,", dvalue);
+        strcat(value_str, temp);
+    }
+    // remove the last comma
+    if (strlen(value_str) > 0) {
+        value_str[strlen(value_str) - 1] = '\0';
+    }
+    av_log(c->fc, AV_LOG_DEBUG, "ICAM box: value=%s\n", value_str);
+    AVStream *st = c->fc->streams[c->fc->nb_streams-1];
+    char keyname[32];
+    snprintf(keyname, sizeof(keyname), "icam_%d", view_id);
+    av_dict_set(&st->metadata, keyname, value_str, AV_DICT_IGNORE_SUFFIX);
+    av_freep(&value_str);
+    return 0;
+}
+
+static int mov_read_ecam(MOVContext *c, AVIOContext *pb, MOVAtom *atom)
+{
+    if (!c || !c->fc) {
+        av_log(NULL, AV_LOG_ERROR, "Invalid context for ICAM box\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    avio_rb32(pb);  // writeInt32(0)
+    // view_id: 0(left), 1(right)
+    int16_t view_id = avio_rb16(pb);  // writeInt16(view_id)
+    view_id &= 0x3FF;
+    avio_r8(pb);  // writeInt8(31)
+    avio_r8(pb);  // writeInt8(31)
+
+    // TODO: revemo hard code for num_doubles
+    // int64_t remaining = atom->size - (4 + 2 + 1 + 1); // 减去已读取的字节数
+    // int num_doubles = remaining / (1 + sizeof(double)); // 每个值包含1字节指数和8字节尾数
+    int num_doubles = 12;     // remaining / (1 + sizeof(double)); // 每个值包含1字节指数和8字节尾数
+
+    // create a buffer to store all double values
+    char *value_str = av_malloc(num_doubles * 32); // each double has at most 32 characters
+    if (!value_str) {
+        return AVERROR(ENOMEM);
+    }
+    value_str[0] = '\0';
+
+    // read all (double) values
+    for (int i = 0; i < num_doubles; i++) {
+        int8_t exponent = avio_r8(pb);
+        double mantissa;
+        int ret = avio_read(pb, (uint8_t*)&mantissa, sizeof(double));
+        if (ret != sizeof(double)) {
+            return AVERROR_INVALIDDATA;
+        }
+        // convert the mantissa and exponent back to double
+        double dvalue = ldexp(mantissa, exponent);
+
+        char temp[32];
+        snprintf(temp, sizeof(temp), "%f,", dvalue);
+        strcat(value_str, temp);
+    }
+    // remove the last comma
+    if (strlen(value_str) > 0) {
+        value_str[strlen(value_str) - 1] = '\0';
+    }
+    av_log(c->fc, AV_LOG_DEBUG, "ECAM box: value=%s\n", value_str);
+    AVStream *st = c->fc->streams[c->fc->nb_streams-1];
+    char keyname[32];
+    snprintf(keyname, sizeof(keyname), "ecam_%d", view_id);
+    av_dict_set(&st->metadata, keyname, value_str, AV_DICT_IGNORE_SUFFIX);
+    av_freep(&value_str);
+    return 0;
+}
+
 static int mov_probe(const AVProbeData *p)
 {
     int64_t offset;
